
矩阵操作
这部分介绍一系列对那些比较大的难以放到内存中的矩阵的基本矩阵操作。madlib提供了两种形式的矩阵存储格式：
Dense密集矩阵：矩阵以分布式一维数组集合表示，例如3*10的如下矩阵：
 row_id |         row_vec
--------+-------------------------
   1    | {9,6,5,8,5,6,6,3,10,8}
   2    | {8,2,2,6,6,10,2,1,9,9}
   3    | {3,9,9,9,8,6,3,9,5,6}
   每一行有一个表示row number的row_id和值的row_vec。row number必须为1到N的不重复序列，N是行的维数。
   
Sparse稀疏矩阵：对于矩阵中的非0值用行和列索引的形式表现。对于包含多个0的element的稀疏矩阵这种表示方法非常有用。以下十一个×7的矩阵，28个element只有6个非0值。矩阵的维数通过row和col的最大值推断出来。最后一个entry（即使值为0）用来提供矩阵的维数。表名第4行，第7列包含的是0.
 row_id | col_id | value
--------+--------+-------
      1 |      1 |     9
      1 |      5 |     6
      1 |      6 |     6
      2 |      1 |     8
      3 |      1 |     3
      3 |      2 |     9
      4 |      7 |     0
所有的矩阵操作在这两种形式上都适用

对于稀疏矩阵，row和col列不能有重复的，并且value列必须是数值类型（不能是array）。该矩阵的dense矩阵如下，，维数是4*7，因为row 和col的最大值分别是4和7，最后那行和那列都是0.
 row_id |         row_vec
--------+-------------------------
   1    | {9,0,0,0,6,6,0}
   2    | {8,0,0,0,0,0,0}
   3    | {3,9,0,0,0,0,0}
   4    | {0,0,0,0,0,0,0}

注意：以下函数支持的几种数据类型包含SMALLINT, INTEGER, BIGINT, DOUBLE PRECISION (FLOAT8), NUMERIC (internally casted into FLOAT8, so loss of precision can happen).

矩阵操作：

以下是支持的矩阵操作，参数(argument)和其它项(term)的意义对所有函数都一致，再后面的词汇表列出来。

矩阵表示(representation)
-- 转换到稀疏矩阵
  matrix_sparsify( matrix_in, in_args, matrix_out, out_args)
 
-- 转换到密集矩阵
  matrix_densify( matrix_in, in_args, matrix_out, out_args)
 
-- 获得矩阵维度
  matrix_ndims( matrix_in, in_args )

矩阵操作
--矩阵转换(Matrix transposition)
  matrix_trans( matrix_in, in_args, matrix_out, out_args)
 
--矩阵相加(Matrix addition)
  matrix_add( matrix_a, a_args, matrix_b, b_args, matrix_out, out_args)
 
--矩阵相减(Matrix subtraction)
  matrix_sub( matrix_a, a_args, matrix_b, b_args, matrix_out, out_args)
 
--矩阵相乘(Matrix multiplication)
  matrix_mult( matrix_a, a_args, matrix_b, b_args, matrix_out, out_args)
 
--对应项相乘(Element-wise matrix multiplication)
  matrix_elem_mult( matrix_a, a_args, matrix_b, b_args, matrix_out, out_args)
 
--矩阵和标量相乘（Multiply matrix with scalar）
  matrix_scalar_mult( matrix_in, in_args, scalar, matrix_out, out_args)
 
--矩阵和向量相乘(Multiply matrix with vector)
  matrix_vec_mult( matrix_in, in_args, vector)

取值/访问方法（Extraction/visitor methods）

--从矩阵中根据row id取出指定行（Extract row from matrix given row index）
  matrix_extract_row( matrix_in, in_args, index)
 
--从矩阵中根据col id取出指定列（Extract column from matrix given column index）
  matrix_extract_col( matrix_in, in_args, index)
 
--取出主对角线element(Extract main (principal) diagonal elements)
  matrix_extract_diag( matrix_in, in_args)

聚合操作（通过指定维度聚合）Reduction operations (aggregate across specific dimension)

--获取维度上的最大值。如果fetch_index = True返回对应的index
-- Get max value along dim. Returns corresponding index if fetch_index = True
  matrix_max( matrix_in, in_args, dim, matrix_out, fetch_index)

--获取维度上的最小值。如果fetch_index = True返回对应的index
-- Get min value along dim. Returns corresponding index if fetch_index = True
  matrix_min( matrix_in, in_args, dim, matrix_out, fetch_index)

-- 在维度上求和
-- Get sum value along dimension
  matrix_sum( matrix_in, in_args, dim)

--在维度上求平均值
-- Get mean value along dimension
  matrix_mean( matrix_in, in_args, dim)
  
--求矩阵的范数
-- Get matrix norm
  matrix_norm( matrix_in, in_args, norm_type)

创建方法

--通过一个给定行和列的维度创建一个矩阵
-- Create a matrix initialized with ones of given row and column dimension
  matrix_ones( row_dim, col_dim, matrix_out, out_args)

--通过一个给定行和列的维度创建一个初始值为0的矩阵
-- Create a matrix initialized with zeros of given row and column dimension
  matrix_zeros( row_dim, col_dim, matrix_out, out_args)

--创建一个dim×dim的矩阵
-- Create an square identity matrix of size dim x dim
  matrix_identity( dim, matrix_out, out_args)

--创建一个对角矩阵，使用指定的对角element初始化
-- Create a diag matrix initialized with given diagonal elements
  matrix_diag( diag_elements, matrix_out, out_args)
  
--创建一个，值遵循以下某种概率分布：normal，uniform，bernoulli
-- Create a matrix initialized with values sampled from a distribution
-- Supported distributions: normal, uniform, bernoulli
  matrix_random( distribution, row_dim, col_dim, in_args, matrix_out, out_args )
使用：select  madlib.matrix_random(5,5,'bernoulli','matrix3');
  
分解操作
注意：以下分解操作用于纯内存中的操作。矩阵数据被汇聚到一个单独的机器节点，分解操作在上面执行。这将导致这些操作只适用于较小的矩阵，因为计算不是分布在多个节点上的。

--矩阵求逆
-- Matrix inverse
  matrix_inverse( matrix_in, in_args, matrix_out, out_args)

--  
-- Matrix generic inverse
  matrix_pinv( matrix_in, in_args, matrix_out, out_args)

--矩阵特征提取
-- Matrix eigen extraction
  matrix_eigen( matrix_in, in_args, matrix_out, out_args)

--Cholesky矩阵分解
-- Matrix Cholesky decomposition
  matrix_cholesky( matrix_in, in_args, matrix_out_prefix, out_args)

--  QR距镇分界
-- Matrix QR decomposition
  matrix_qr( matrix_in, in_args, matrix_out_prefix, out_args)

--LU矩阵分解
-- Matrix LU decomposition
  matrix_lu( matrix_in, in_args, matrix_out_prefix, out_args)

--矩阵核范数计算
-- Matrix nuclear norm computing
  matrix_nuclear_norm( matrix_in, in_args)

--矩阵的秩计算
-- Matrix rank computing
  matrix_rank( matrix_in, in_args)
  
词汇表
matrix_in, matrix_a, matrix_b
    文本类型，包含输入矩阵的表
        对于只包含一个矩阵的函数，matrix_in表示输入矩阵
        对于包含两个矩阵的函数，matrix_a表示一一个矩阵，matrix_b表示第二个矩阵。这两个矩阵可以独立的分别是稀疏矩阵sparse matrix或者密集矩阵dense matrix。
in_args, a_args, b_args
    文本类型，逗号分隔的字符串，以name=value这种形式包含多个参数。这个参数用于某个矩阵有关的多个变量的容器
TEXT. A comma-delimited string containing multiple named arguments of the form "name=value". This argument is used as a container for multiple parameters related to a single matrix.
该参数支持以下变量
    row	(Default: 'row_num')矩阵的行索引row index
    col	(Default: 'col_num')矩阵的列索引.
    val	(Default: 'val') 矩阵的项entry
    trans	(Default: False) Boolean值指明矩阵在操作前是否需要被转置transposed.目前仅用于matrix_mult.
    例如, 改参数的默认值为 'row=row_num, col=col_num, val=val, trans=False'.如果钥匙用默认值该参数可以被设置为NULL 或者为空('')。
    
matrix_out
文本类型. 存储结果矩阵的表名.

对 Cholesky, QR 和 LU 分解, 某个前缀prefix (matrix_out_prefix)被用来作为将要生成的多个输出表表名的基本值.

对 Cholesky 分解 ( $ PA = LDL* $),如下后缀会被加到matrix_out_prefix:
    _p for row permutation matrix P
    _l for lower triangular factor L
    _d for diagonal matrix D
    
对 QR 分解 ( $ A = QR $) 如下后缀会加到matrix_out_prefix:
    _q for orthogonal matrix Q
    _r for upper triangular factor R

For LU decomposition with full pivoting ( $ PAQ = LU $), the following suffixes are added to matrix_out_prefix:0
    _p for row permutation matrix P
    _q for column permutation matrix Q
    _l for lower triangular factor L
    _u for upper triangular factor U

out_args
文本类型. 文本类型，逗号分隔的字符串，以name=value这种形式包含多个参数。这是一个可选参数默认值可按以下说明设置:
对于一个输入矩阵的函数,默认的 out_args 会和 in_args相同.
对于两个输入矩阵的函数,默认的 out_args 会和 a_args相同.
该参数支持以下变量:
    row	包含矩阵的row index.
    col	包含矩阵的col index.
    val	包含矩阵的entries.
    fmt	输出矩阵的格式.它可以是 'dense' 或者 'sparse'. 当 'fmt' 没有说明, 输出的 fmt 取决于输入矩阵.
注意：一个例外就是 matrix_eigen:默认的输出 column name 是(real, imaginary)格式的 ’eigen_values’.

index
INTEGER. 代表矩阵行或者列index的整数. 取值从 1 到 N, N是维度的最大数量.

dim
INTEGER. 必须为 1 或者 2.改值表明reduction/aggregation操作执行的维度.dim的值必须被声明来指明哪个维度在结果集中会降到1.

在N x M矩阵上执行的任意聚合reduce函数
如果dim=1，操作将作用于每列上连续的项elements，返回值是一个M项的单向量（类似于1行M列的矩阵）
如果dim=2，操作将作用于每行上连续的项elements，返回值是一个N项的单向量（类似于N行1列的矩阵）

row_dim
INTEGER. 大于 0. This value indicates the row dimension of result matrix.

col_dim
INTEGER. 大于 0. This value indicates the column dimension of result matrix.

diag_elements
ARRAY OF FLOAT. 非空. This value indicates the float array which is used to generate diag elements of result output matrix.

norm_type
TEXT. Optional变量. 默认是 Frobenius 范数. 其它支持的范数:
    'one' or 'o'	1 范数
    float > 0	Element-wise 范数
    'inf' or 'i'	Infinite 范数
    'max' or 'm'	Max absolute value 范数
    'fro' or 'f'	Frobenius 范数 (默认选项)


例子：
先生成一个密集矩阵dense matrix
CREATE TABLE "mat_A" (
        row_id integer,
        row_vec integer[]
);
INSERT INTO "mat_A" (row_id, row_vec) VALUES (1, '{9,6,5,8,5,6,6,3,10,8}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (2, '{8,2,2,6,6,10,2,1,9,9}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (3, '{3,9,9,9,8,6,3,9,5,6}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (4, '{6,4,2,2,2,7,8,8,0,7}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (5, '{6,8,9,9,4,6,9,5,7,7}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (6, '{4,10,7,3,9,5,9,2,3,4}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (7, '{8,10,7,10,1,9,7,9,8,7}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (8, '{7,4,5,6,2,8,1,1,4,8}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (9, '{8,8,8,5,2,6,9,1,8,3}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (10, '{4,6,3,2,6,4,1,2,3,8}');

CREATE TABLE "mat_B" (
    row_id integer,
    vector integer[]
);
INSERT INTO "mat_B" (row_id, vector) VALUES (1, '{9,10,2,4,6,5,3,7,5,6}');
INSERT INTO "mat_B" (row_id, vector) VALUES (2, '{5,3,5,2,8,6,9,7,7,6}');
INSERT INTO "mat_B" (row_id, vector) VALUES (3, '{0,1,2,3,2,7,7,3,10,1}');
INSERT INTO "mat_B" (row_id, vector) VALUES (4, '{2,9,0,4,3,6,8,6,3,4}');
INSERT INTO "mat_B" (row_id, vector) VALUES (5, '{3,8,7,7,0,5,3,9,2,10}');
INSERT INTO "mat_B" (row_id, vector) VALUES (6, '{5,3,1,7,6,3,5,3,6,4}');
INSERT INTO "mat_B" (row_id, vector) VALUES (7, '{4,8,4,4,2,7,10,0,3,3}');
INSERT INTO "mat_B" (row_id, vector) VALUES (8, '{4,6,0,1,3,1,6,6,9,8}');
INSERT INTO "mat_B" (row_id, vector) VALUES (9, '{6,5,1,7,2,7,10,6,0,6}');
INSERT INTO "mat_B" (row_id, vector) VALUES (10, '{1,4,4,4,8,5,2,8,5,5}');
结果：
select * from "mat_A";
 row_id |         row_vec         
--------+-------------------------
      1 | {9,6,5,8,5,6,6,3,10,8}
      2 | {8,2,2,6,6,10,2,1,9,9}
      3 | {3,9,9,9,8,6,3,9,5,6}
      4 | {6,4,2,2,2,7,8,8,0,7}
      5 | {6,8,9,9,4,6,9,5,7,7}
      6 | {4,10,7,3,9,5,9,2,3,4}
      7 | {8,10,7,10,1,9,7,9,8,7}
      8 | {7,4,5,6,2,8,1,1,4,8}
      9 | {8,8,8,5,2,6,9,1,8,3}
     10 | {4,6,3,2,6,4,1,2,3,8}
(10 rows)

select * from "mat_B";
 row_id |         vector         
--------+------------------------
      1 | {9,10,2,4,6,5,3,7,5,6}
      2 | {5,3,5,2,8,6,9,7,7,6}
      3 | {0,1,2,3,2,7,7,3,10,1}
      4 | {2,9,0,4,3,6,8,6,3,4}
      5 | {3,8,7,7,0,5,3,9,2,10}
      6 | {5,3,1,7,6,3,5,3,6,4}
      7 | {4,8,4,4,2,7,10,0,3,3}
      8 | {4,6,0,1,3,1,6,6,9,8}
      9 | {6,5,1,7,2,7,10,6,0,6}
     10 | {1,4,4,4,8,5,2,8,5,5}
     
进行矩阵转置transpose
SELECT madlib.matrix_trans('"mat_B"', 'row=row_id, val=vector',
                            'mat_r');
-- 注意结果矩阵继承了列名'vector'作为值那列的默认名称
 matrix_trans 
--------------
 (mat_r)
(1 row)

 SELECT * FROM mat_r ORDER BY row_id;
 row_id |         vector          
--------+-------------------------
      1 | {9,5,0,2,3,5,4,4,6,1}
      2 | {10,3,1,9,8,3,8,6,5,4}
      3 | {2,5,2,0,7,1,4,0,1,4}
      4 | {4,2,3,4,7,7,4,1,7,4}
      5 | {6,8,2,3,0,6,2,3,2,8}
      6 | {5,6,7,6,5,3,7,1,7,5}
      7 | {3,9,7,8,3,5,10,6,10,2}
      8 | {7,7,3,6,9,3,0,6,6,8}
      9 | {5,7,10,3,2,6,3,9,0,5}
     10 | {6,6,1,4,10,4,3,8,6,5}

提取矩阵的主对角main diagonal
--注意结果是一个array
SELECT madlib.matrix_extract_diag('"mat_B"', 'row=row_id, val=vector');
  matrix_extract_diag   
------------------------
 {9,3,2,4,0,3,10,6,0,5}

矩阵相加
SELECT madlib.matrix_add('"mat_A"', 'row=row_id, val=row_vec',
                         '"mat_B"', 'row=row_id, val=vector',
                         'mat_r', 'val=vector, fmt=dense');
 matrix_add 
------------
 (mat_r)
(1 row)

SELECT * FROM mat_r ORDER BY row_id;
 row_id |            vector             
--------+-------------------------------
      1 | {18,16,7,12,11,11,9,10,15,14}
      2 | {13,5,7,8,14,16,11,8,16,15}
      3 | {3,10,11,12,10,13,10,12,15,7}
      4 | {8,13,2,6,5,13,16,14,3,11}
      5 | {9,16,16,16,4,11,12,14,9,17}
      6 | {9,13,8,10,15,8,14,5,9,8}
      7 | {12,18,11,14,3,16,17,9,11,10}
      8 | {11,10,5,7,5,9,7,7,13,16}
      9 | {14,13,9,12,4,13,19,7,8,9}
     10 | {5,10,7,6,14,9,3,10,8,13}
     
矩阵相乘
SELECT madlib.matrix_mult('"mat_A"', 'row=row_id, val=row_vec',
                           '"mat_B"', 'row=row_id, val=vector, trans=true',
                           'mat_r');
 matrix_mult 
-------------
 (mat_r)
(1 row)

SELECT * FROM mat_r ORDER BY row_id;
 row_id |                  row_vec                  
--------+-------------------------------------------
      1 | {380,373,251,283,341,303,302,309,323,281}
      2 | {318,318,222,221,269,259,236,249,264,248}
      3 | {382,366,216,300,397,276,277,270,313,338}
      4 | {275,284,154,244,279,183,226,215,295,204}
      5 | {381,392,258,319,394,298,342,302,360,300}
      6 | {321,333,189,276,278,232,300,236,281,250}
      7 | {443,411,282,365,456,318,360,338,406,330}
      8 | {267,240,150,186,270,194,210,184,233,193}
      9 | {322,328,234,264,291,245,317,253,291,219}
     10 | {246,221,109,173,222,164,167,185,181,189}

创建一个对角矩阵
--这里是稀疏矩阵格式输出
SELECT madlib.matrix_diag(array[9,6,3,10],
                          'mat_r', 'row=row_id, col=col_id, val=val');
 matrix_diag 
-------------
 (mat_r)
(1 row)

SELECT * FROM mat_r ORDER BY row_id::bigint;
 row_id | col_id | val 
--------+--------+-----
      1 |      1 |   9
      2 |      2 |   6
      3 |      3 |   3
      4 |      4 |  10

创建一个单位矩阵identity matrix
SELECT madlib.matrix_identity(4, 'mat_r', 'row=row_id,col=col_id,val=val');
 matrix_identity 
-----------------
 (mat_r)
(1 row)

SELECT * FROM mat_r ORDER BY row_id;
 row_id | col_id | val 
--------+--------+-----
      1 |      1 |   1
      2 |      2 |   1
      3 |      3 |   1
      4 |      4 |   1

通过行或者列索引从矩阵中取出行或列
SELECT madlib.matrix_extract_row('"mat_A"', 'row=row_id, val=row_vec', 2) as row,
-        madlib.matrix_extract_col('"mat_A"', 'row=row_id, val=row_vec', 3) as col;
          row           |          col          
------------------------+-----------------------
 {8,2,2,6,6,10,2,1,9,9} | {5,2,9,2,9,7,7,5,8,3}
 
获取指定维度上的最大/最小值, 以及对应的index.本例中 dim=2 表明最大最小计算发生在每行上, 返回一个列向量 也就是说列 (dim=2) is flattened.
SELECT madlib.matrix_max('"mat_A"', 'row=row_id, val=row_vec', 2, 'mat_max_r', true),
       madlib.matrix_min('"mat_A"', 'row=row_id, val=row_vec', 2, 'mat_min_r', true);
 matrix_max  | matrix_min  
-------------+-------------
 (mat_max_r) | (mat_min_r)
(1 row)

 SELECT * from mat_max_r;
         index          |            max            
------------------------+---------------------------
 {9,6,2,7,3,2,2,6,7,10} | {10,10,9,8,9,10,10,8,9,8}
(1 row)

 SELECT * from mat_min_r;
         index         |          min          
-----------------------+-----------------------
 {8,8,1,9,5,8,5,7,8,7} | {3,1,3,0,4,2,1,1,1,1}
 
初始化一个稀疏矩阵，填充值为0
SELECT madlib.matrix_zeros(5, 4, 'mat_r', 'row=row_id, col=col_id, val=entry');
 matrix_zeros 
--------------
 (mat_r)
(1 row)

SELECT * FROM mat_r;
 row_id | col_id | entry 
--------+--------+-------
      5 |      4 |     0
      
初始化一个密集矩阵，填充值为0
SELECT madlib.matrix_zeros(5, 4, 'mat_r', 'fmt=dense');
 matrix_zeros 
--------------
 (mat_r)
(1 row)

SELECT * FROM mat_r;
 row |    val    
-----+-----------
   1 | {0,0,0,0}
   2 | {0,0,0,0}
   3 | {0,0,0,0}
   4 | {0,0,0,0}
   5 | {0,0,0,0}

将矩阵值初始化为1
--稀疏矩阵
SELECT madlib.matrix_ones(5, 4, 'mat_r', 'row=row,col=col, val=val');
 matrix_ones 
-------------
 (mat_r)
(1 row)

SELECT * FROM mat_r;
 row | col | val 
-----+-----+-----
   1 |   1 |   1
   1 |   2 |   1
   1 |   3 |   1
   1 |   4 |   1
   2 |   1 |   1
   2 |   2 |   1
   2 |   3 |   1
   2 |   4 |   1
   3 |   1 |   1
   3 |   2 |   1
   3 |   3 |   1
   3 |   4 |   1
   4 |   1 |   1
   4 |   2 |   1
   4 |   3 |   1
   4 |   4 |   1
   5 |   1 |   1
   5 |   2 |   1
   5 |   3 |   1
   5 |   4 |   1
--密集矩阵   
SELECT * FROM mat_r;
 row |    val    
-----+-----------
   1 | {1,1,1,1}
   2 | {1,1,1,1}
   3 | {1,1,1,1}
   4 | {1,1,1,1}
   5 | {1,1,1,1}
   
矩阵element-wisely乘法（行和列上相同位置的element相乘）
SELECT madlib.matrix_elem_mult('"mat_A"', 'row=row_id, val=row_vec',
                                '"mat_B"', 'row=row_id, val=vector',
                                'mat_r', 'val=vector');
 matrix_elem_mult 
------------------
 (mat_r)
(1 row)

SELECT * FROM mat_r;
 row_id |             vector              
--------+---------------------------------
      1 | {81,60,10,32,30,30,18,21,50,48}
      2 | {40,6,10,12,48,60,18,7,63,54}
      3 | {0,9,18,27,16,42,21,27,50,6}
      4 | {12,36,0,8,6,42,64,48,0,28}
      5 | {18,64,63,63,0,30,27,45,14,70}
      6 | {20,30,7,21,54,15,45,6,18,16}
      7 | {32,80,28,40,2,63,70,0,24,21}
      8 | {28,24,0,6,6,8,6,6,36,64}
      9 | {48,40,8,35,4,42,90,6,0,18}
     10 | {4,24,12,8,48,20,2,16,15,40}
(10 rows)

select * from "mat_A";                                                 
 row_id |         row_vec         
--------+-------------------------
      1 | {9,6,5,8,5,6,6,3,10,8}
      2 | {8,2,2,6,6,10,2,1,9,9}
      3 | {3,9,9,9,8,6,3,9,5,6}
      4 | {6,4,2,2,2,7,8,8,0,7}
      5 | {6,8,9,9,4,6,9,5,7,7}
      6 | {4,10,7,3,9,5,9,2,3,4}
      7 | {8,10,7,10,1,9,7,9,8,7}
      8 | {7,4,5,6,2,8,1,1,4,8}
      9 | {8,8,8,5,2,6,9,1,8,3}
     10 | {4,6,3,2,6,4,1,2,3,8}
(10 rows)

select * from "mat_B";
 row_id |         vector         
--------+------------------------
      1 | {9,10,2,4,6,5,3,7,5,6}
      2 | {5,3,5,2,8,6,9,7,7,6}
      3 | {0,1,2,3,2,7,7,3,10,1}
      4 | {2,9,0,4,3,6,8,6,3,4}
      5 | {3,8,7,7,0,5,3,9,2,10}
      6 | {5,3,1,7,6,3,5,3,6,4}
      7 | {4,8,4,4,2,7,10,0,3,3}
      8 | {4,6,0,1,3,1,6,6,9,8}
      9 | {6,5,1,7,2,7,10,6,0,6}
     10 | {1,4,4,4,8,5,2,8,5,5}
     
在维度上求和.在本例中是每行求和 (i.e. column is flattened since dim=2).
SELECT madlib.matrix_sum('"mat_A"', 'row=row_id, val=row_vec', 2);
           matrix_sum            
---------------------------------
 {66,55,67,46,70,56,76,46,58,39}

在维度上求平均值
SELECT madlib.matrix_mean('"mat_A"', 'row=row_id, val=row_vec', 2);
               matrix_mean               
-----------------------------------------
 {6.6,5.5,6.7,4.6,7,5.6,7.6,4.6,5.8,3.9}

计算矩阵的范数，本例中是Euclidean范数
SELECT madlib.matrix_norm('"mat_A"', 'row=row_id, val=row_vec', '2');
   matrix_norm    
------------------
 64.1014820421494

矩阵和标量值相乘
SELECT madlib.matrix_scalar_mult('"mat_A"', 'row=row_id, val=row_vec', 3, 'mat_r');
 matrix_scalar_mult 
--------------------
 (mat_r)
(1 row)

SELECT * FROM mat_r;
 row_id |             row_vec             
--------+---------------------------------
      1 | {27,18,15,24,15,18,18,9,30,24}
      2 | {24,6,6,18,18,30,6,3,27,27}
      3 | {9,27,27,27,24,18,9,27,15,18}
      4 | {18,12,6,6,6,21,24,24,0,21}
      5 | {18,24,27,27,12,18,27,15,21,21}
      6 | {12,30,21,9,27,15,27,6,9,12}
      7 | {24,30,21,30,3,27,21,27,24,21}
      8 | {21,12,15,18,6,24,3,3,12,24}
      9 | {24,24,24,15,6,18,27,3,24,9}
     10 | {12,18,9,6,18,12,3,6,9,24}

获得矩阵行和列的维数
SELECT madlib.matrix_ndims('"mat_A"', 'row=row_id, val=row_vec');
 matrix_ndims 
--------------
 {10,10}

矩阵和向量相乘
SELECT madlib.matrix_vec_mult('"mat_A"', 'row=row_id, val=row_vec',
                               array[1,2,3,4,5,6,7,8,9,10]);
              matrix_vec_mult              
-------------------------------------------
 {365,325,358,270,377,278,411,243,287,217}
 
Inverse of matrix 逆矩阵
SELECT madlib.matrix_inverse('"mat_A"', 'row=row_id, val=row_vec', 'mat_r');
 matrix_inverse 
----------------
 (mat_r)
(1 row)

SELECT row_vec FROM mat_r ORDER BY row_id;
                                                                                                row_vec                 
                                                                               
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 {0.330062608235873,-0.188478647250356,0.0906400882955738,0.0962013572416859,-0.30222707027194,0.0239424284417788,-0.0988370758320984,0.185846793705872,0.0559643246178135,-0.138053885704785}
 {-0.00766847518140578,-0.0518249724594472,-0.0925050849860583,-0.0878580954549273,-0.070301180343015,0.115163300571094,0.182608968178097,0.00717747431067815,-0.0705340633639551,0.0756480512704504}
 {-0.117746234210599,-0.0128995814482015,0.139966364577851,0.0470798443708449,0.0780882116071194,-0.173507671924782,-0.187856477550436,0.0169443986909519,0.224999363527763,0.067570534730878}
 {0.185710378123511,-0.0749519882407751,-0.0581914032920277,-0.0717714382124376,0.00422455121425333,0.175292987052479,0.0885535889971591,0.159129000883854,-0.265202591003557,-0.223451225916481}
 {0.119399400243832,-0.000236514670374639,0.079533906829595,0.0215562013667643,-0.0989066653305184,0.0835408204818456,-0.0808650323814762,0.0168783848268081,-0.0394795676447595,-0.0841891492607264}
 {-0.22559164914069,0.161802688415784,-0.0195339981343031,-0.0141008078478133,0.0125198080102852,0.0423170061563366,0.0785120876463955,-0.00479737155964581,0.021854622123002,-0.0336571933737466}
 {-0.0233121272080347,0.0332144495619582,-0.0860506543396722,0.0232453944826918,0.135352199929527,0.0516493182586459,0.00362319114566899,-0.0600261424611303,-0.0516474604225599,-0.0378900441672989}
 {0.0110534805378086,-0.00583298914352479,0.114956492606377,0.0862945163316536,-0.062772995125757,-0.108557535638501,-0.0296829178871086,-0.0878853094860373,0.0801059056193315,0.0268068475879728}
 {-0.12185614106738,0.133403311203518,0.00713056161553993,-0.0424716453368879,0.0845253335695678,-0.139319566879966,0.0160363649661295,-0.214772517353799,0.136619682925636,0.148800617899478}
 {-0.0924597313794947,0.0232396342572389,-0.0844209493219379,0.000411627391311615,0.208497521931405,-0.0879876211728075,-0.0168834822062201,-0.0446887159694726,-0.0392762886350201,0.190019530898629}

Generic inverse of matrix
SELECT madlib.matrix_pinv('"mat_A"', 'row=row_id, val=row_vec', 'mat_r');
 matrix_pinv 
-------------
 (mat_r)
(1 row)

 SELECT row_vec FROM mat_r ORDER BY row_id;
                                                                                                row_vec                 
                                                                               
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 {0.330062608235873,-0.188478647250356,0.0906400882955739,0.0962013572416859,-0.302227070271941,0.0239424284417786,-0.0988370758320985,0.185846793705872,0.0559643246178136,-0.138053885704785}
 {-0.00766847518140564,-0.0518249724594474,-0.0925050849860583,-0.0878580954549273,-0.070301180343015,0.115163300571094,0.182608968178097,0.00717747431067819,-0.0705340633639552,0.0756480512704504}
 {-0.117746234210599,-0.0128995814482014,0.139966364577851,0.0470798443708449,0.0780882116071196,-0.173507671924782,-0.187856477550436,0.0169443986909518,0.224999363527763,0.0675705347308781}
 {0.185710378123512,-0.0749519882407753,-0.0581914032920275,-0.0717714382124375,0.00422455121425298,0.175292987052479,0.088553588997159,0.159129000883854,-0.265202591003557,-0.223451225916481}
 {0.119399400243832,-0.000236514670374641,0.0795339068295951,0.0215562013667643,-0.0989066653305185,0.0835408204818455,-0.0808650323814763,0.0168783848268082,-0.0394795676447595,-0.0841891492607264}
 {-0.22559164914069,0.161802688415784,-0.0195339981343031,-0.0141008078478133,0.0125198080102854,0.0423170061563367,0.0785120876463954,-0.0047973715596457,0.0218546221230018,-0.0336571933737467}
 {-0.0233121272080347,0.0332144495619583,-0.0860506543396722,0.0232453944826917,0.135352199929527,0.051649318258646,0.00362319114566904,-0.0600261424611304,-0.0516474604225599,-0.0378900441672989}
 {0.0110534805378085,-0.00583298914352468,0.114956492606377,0.0862945163316535,-0.0627729951257569,-0.108557535638501,-0.0296829178871086,-0.0878853094860374,0.0801059056193315,0.0268068475879729}
 {-0.12185614106738,0.133403311203518,0.00713056161553979,-0.0424716453368879,0.0845253335695681,-0.139319566879966,0.0160363649661297,-0.2147725173538,0.136619682925636,0.148800617899478}
 {-0.0924597313794948,0.0232396342572391,-0.0844209493219379,0.000411627391311577,0.208497521931405,-0.0879876211728074,-0.01688348220622,-0.0446887159694727,-0.0392762886350201,0.190019530898629}

矩阵的特征值Eigen values (注意特征值的默认列名)
SELECT madlib.matrix_eigen('"mat_A"', 'row=row_id, val=row_vec', 'mat_r');
 matrix_eigen 
--------------
 (mat_r)
(1 row)

SELECT eigen_values FROM mat_r ORDER BY row_id;
              eigen_values              
----------------------------------------
 (57.6035400578663,0)
 (-6.00515271659106,3.07748111881699)
 (-6.00515271659106,-3.07748111881699)
 (0.0104507154196393,5.74378328714543)
 (0.0104507154196393,-5.74378328714543)
 (6.52505840852947,0)
 (2.86780748553491,2.36130479230656)
 (2.86780748553491,-2.36130479230656)
 (-5.41398228236282,0)
 (2.53917284724008,0)
 
矩阵的Cholesky 分解
SELECT madlib.matrix_cholesky('"mat_A"', 'row=row_id, val=row_vec', 'matrix_out_prefix');
                                    matrix_cholesky                                     
----------------------------------------------------------------------------------------
 ("                                                                                    +
             For Cholesky decomposition with left pivoting (PA = LDL*),                +
             the corresponding matrices can be obtained by appending following suffixes+
             to matrix_out_prefix:                                                     +
                   _p for row permutation matrix P                                     +
                   _l for lower triangular factor L                                    +
                   _d for diagonal matrix D                                            +
             ")
(1 row)

SELECT row_vec FROM matrix_out_prefix_p ORDER BY row_id;
        row_vec        
-----------------------
 {1,0,0,0,0,0,0,0,0,0}
 {0,0,1,0,0,0,0,0,0,0}
 {0,0,0,0,0,0,0,0,1,0}
 {0,0,0,0,0,0,0,0,0,1}
 {0,0,0,0,0,0,1,0,0,0}
 {0,0,0,0,0,1,0,0,0,0}
 {0,0,0,0,1,0,0,0,0,0}
 {0,1,0,0,0,0,0,0,0,0}
 {0,0,0,1,0,0,0,0,0,0}
 {0,0,0,0,0,0,0,1,0,0}
(10 rows)

SELECT row_vec FROM matrix_out_prefix_l ORDER BY row_id;
                                                                         row_vec                                        
                                 
------------------------------------------------------------------------------------------------------------------------
---------------------------------
 {1,0,0,0,0,0,0,0,0,0}
 {0.333333333333333,1,0,0,0,0,0,0,0,0}
 {0.888888888888889,0.666666666666667,1,0,0,0,0,0,0,0}
 {0.444444444444444,0.208333333333333,0.625,1,0,0,0,0,0,0}
 {0.888888888888889,0.541666666666667,0.375,-0.409638554216867,1,0,0,0,0,0}
 {0.444444444444444,0.708333333333333,0.5,0.271084337349398,-1.1230269266481,1,0,0,0,0}
 {0.666666666666667,0.875,3,0.993975903614458,0.711699164345404,0.2656239511311,1,0,0,0}
 {0.888888888888889,0.791666666666667,1.25,0.463855421686747,-0.623491179201486,1.45364838558099,0.0933485137082021,1,0,
0}
 {0.666666666666667,1.38777878078145e-17,0.125,-0.0662650602409638,-1.41922005571031,1.67570651809089,0.131810259703119,
0.471284423105762,1,0}
 {0.777777777777778,0.333333333333333,2.625,0.391566265060241,0.903899721448468,0.715110424917769,1.18467357697475,0.267
499478302543,2.60400206972304,1}
(10 rows)

SELECT row_vec FROM matrix_out_prefix_d ORDER BY row_id;
                row_vec                
---------------------------------------
 {9,0,0,0,0,0,0,0,0,0}
 {0,8,0,0,0,0,0,0,0,0}
 {0,0,-2.66666666666667,0,0,0,0,0,0,0}
 {0,0,0,6.91666666666667,0,0,0,0,0,0}
 {0,0,0,0,-3.24397590361446,0,0,0,0,0}
 {0,0,0,0,0,3.45798514391829,0,0,0,0}
 {0,0,0,0,0,0,12.4405585017118,0,0,0}
 {0,0,0,0,0,0,0,-13.6009216142278,0,0}
 {0,0,0,0,0,0,0,0,-2.35998552735877,0}
 {0,0,0,0,0,0,0,0,0,12.3794209818677}
 
矩阵的 QR分解
SELECT madlib.matrix_qr('"mat_A"', 'row=row_id, val=row_vec', 'matrix_out_prefix');
                                       matrix_qr                                        
----------------------------------------------------------------------------------------
 ("                                                                                    +
             For QR decomposition (A = QR),                                            +
             the corresponding matrices can be obtained by appending following suffixes+
             to matrix_out_prefix:                                                     +
                   _q for orthogonal matrix Q                                          +
                   _r for upper triangular factor R                                    +
             ")
(1 row)

SELECT row_vec FROM matrix_out_prefix_q ORDER BY row_id;
                                                                                             row_vec                    
                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 {-0.431516971336846,-0.201137973600526,0.0683725147617,0.189734382316962,0.127879832564862,0.75380576113268,0.0732572906135879,0.171279616287221,0.183729135137955,-0.282181807777172}
 {-0.383570641188307,-0.460576809114249,0.0119193874133629,0.182159984037789,0.505402803020163,-0.290727345303912,0.0982859314840392,-0.328892721058597,-0.380266752966935,0.0709260335169255}
 {-0.143838990445615,0.524707757218764,-0.351935596784027,0.344429136334643,0.328096247138545,-0.184621140773983,-0.117109531470441,0.438795384572111,-0.217097748079764,-0.257647905077222}
 {-0.28767798089123,-0.134091982400351,0.33486920116944,-0.212264192639444,-0.0849079480150491,-0.377495395790922,0.462906893179212,0.598955698333547,0.139006540140047,0.00125626323674008}
 {-0.28767798089123,0.204053016696186,-0.488830331532117,0.0565433691869197,-0.062558802349854,0.103146648649582,0.402224336134985,-0.102589869094916,0.204164737708329,0.636322502540954}
 {-0.191785320594154,0.530537843410084,0.26805076921642,-0.347222925392324,0.32656098392907,-0.0410777712176104,0.212856673012553,-0.447995740538293,0.250769487432723,-0.268533183409855}
 {-0.383570641188307,0.215713189078825,0.317211113476318,0.511472726006764,-0.586914233347337,-0.155254236062388,-0.0571455190289252,-0.247702371229551,-0.0909109343875847,-0.0515274212832239}
 {-0.335624311039769,-0.212798145983166,-0.303737643254275,-0.108274241280186,-0.0472650422260128,-0.324965399775174,-0.505706099498815,-0.0359878143372868,0.595501135844344,-0.136387403157684}
 {-0.383570641188307,0.0466406895305569,-0.247284515905938,-0.599488396375131,-0.315574985752375,0.11643448178977,-0.130808327809992,0.00601581748294594,-0.534323963278748,-0.11986898474016}
 {-0.191785320594154,0.192392844313547,0.440853371429287,-0.103228756991554,0.237723989048056,0.122787433721189,-0.523228767428908,0.193108546305672,-0.0472173336669296,0.579928731588733}
(10 rows)

SELECT row_vec FROM matrix_out_prefix_r ORDER BY row_id;
                                                                                       row_vec                          
                                                              
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 {-20.8566536146142,-19.4182637101581,-16.7332692218399,-18.9388004086727,-12.0345288672831,-21.192277925654,-17.0688935328797,-11.6509582260948,-19.1305857292668,-20.6169219638715}
 {0,11.8292448821875,9.47389006089436,5.00804403834354,6.78913536979168,1.56246309927366,6.89407692123543,6.82703093003526,1.31176939304691,1.49250206497782}
 {0,0,-4.60902465425305,-4.47953676371697,0.585055146906263,-0.126123087390677,0.202237500914885,1.00610465575521,-2.91931604082463,1.11266626045315}
 {0,0,0,6.01457266752839,-0.049721421826633,1.87109238957369,-3.80480535958349,5.43041719445731,3.16615557027206,2.83477217389472}
 {0,0,0,0,8.92933335296999,1.8500785816068,-2.298986165443,-1.66664725305817,1.31387416930347,4.28276503758146} {0,0,0,0,0,-4.52839716275345,0.685125902043909,-3.63752996949092,3.35514169449786,-2.13347911367676}
 {0,0,0,0,0,0,6.9175427895797,3.20688055879761,-0.61040247087074,-1.34860273536224} {0,0,0,0,0,0,0,5.64373310376032,-2.61349575747887,2.26664930030937}
 {0,0,0,0,0,0,0,0,-3.25066317841929,2.29704469746215}
 {0,0,0,0,0,0,0,0,0,3.0519427600214}

 矩阵的 LU 分解
SELECT madlib.matrix_lu('"mat_A"', 'row=row_id, val=row_vec', 'matrix_out_prefix');
                                       matrix_lu                                        
----------------------------------------------------------------------------------------
 ("                                                                                    +
             For LU decomposition with full pivoting (PAQ = LU),                       +
             the corresponding matrices can be obtained by appending following suffixes+
             to matrix_out_prefix:                                                     +
                   _p for row permutation matrix P                                     +
                   _q for column permutation matrix Q                                  +
                   _l for lower triangular factor L                                    +
                   _u for upper triangular factor U                                    +
             ")
(1 row)

SELECT row_vec FROM matrix_out_prefix_l ORDER BY row_id;
                                                                          row_vec                                       
                                   
------------------------------------------------------------------------------------------------------------------------
-----------------------------------
 {1,0,0,0,0,0,0,0,0,0}
 {0.2,1,0,0,0,0,0,0,0,0}
 {1,0.444444444444444,1,0,0,0,0,0,0,0}
 {0.9,0.166666666666667,0.0810810810810811,1,0,0,0,0,0,0}
 {0.4,0.555555555555556,0.398648648648649,0.638144329896907,1,0,0,0,0,0}
 {0.4,0.666666666666667,0.445945945945946,-0.488659793814433,-0.509990879694884,1,0,0,0,0}
 {0.8,0.222222222222222,0.418918918918919,0.0680412371134021,0.358096343586767,-0.711313709945528,1,0,0,0}
 {0.6,0.111111111111111,-0.0135135135135135,0.125773195876289,-0.461570350717188,0.461473544229343,-0.674924201911364,1,0,0}
 {0.8,0.222222222222222,0.621621621621622,-0.750515463917526,-0.0810048918000167,-0.460655192696212,0.919003993807434,-0.491335835820472,1,0}
 {0.6,0.333333333333333,0.182432432432432,0.0567010309278351,0.144266644556836,-0.94326522261719,0.477544925945472,0.501575033905987,-0.169556693855548,1}
(10 rows)

SELECT row_vec FROM matrix_out_prefix_u ORDER BY row_id;
                                                              row_vec                                                   
           
------------------------------------------------------------------------------------------------------------------------
-----------
 {10,5,9,2,9,3,7,4,3,4}
 {0,9,4.2,0.6,0.2,8.4,0.6,8.2,5.4,7.2}
 {0,0,-9.86666666666667,6.73333333333333,-2.08888888888889,1.26666666666667,-0.266666666666667,-0.644444444444444,4.6,0.8}
 {0,0,0,6.55405405405405,-4.96396396396396,0.797297297297297,2.62162162162162,1.08558558558559,5.02702702702703,-1.86486486486486}
 {0,0,0,0,8.2893470790378,-6.88041237113402,-2.7,0.408591065292097,-7.24175257731959,1.27113402061856}
 {0,0,0,0,0,-6.48420528977697,1.82302462482381,1.95958046596468,-2.08807312826465,-0.0197744797280485}
 {0,0,0,0,0,0,5.46360253688975,3.42144464619083,4.23889791064624,0.522498273789735}
 {0,0,0,0,0,0,0,6.13715738737358,-0.488156073267,1.99385073013072}
 {0,0,0,0,0,0,0,0,-3.3705097328725,1.89642395515887}
 {0,0,0,0,0,0,0,0,0,3.02972822442634}
(10 rows)

SELECT row_vec FROM matrix_out_prefix_p ORDER BY row_id;
        row_vec        
-----------------------
 {0,0,0,0,0,1,0,0,0,0}
 {0,1,0,0,0,0,0,0,0,0}
 {0,0,0,0,0,0,1,0,0,0}
 {0,0,1,0,0,0,0,0,0,0}
 {0,0,0,1,0,0,0,0,0,0}
 {0,0,0,0,0,0,0,1,0,0}
 {0,0,0,0,1,0,0,0,0,0}
 {0,0,0,0,0,0,0,0,0,1}
 {0,0,0,0,0,0,0,0,1,0}
 {1,0,0,0,0,0,0,0,0,0}
(10 rows)

SELECT row_vec FROM matrix_out_prefix_q ORDER BY row_id;
        row_vec        
-----------------------
 {0,0,0,0,0,0,0,0,0,1}
 {1,0,0,0,0,0,0,0,0,0}
 {0,0,0,0,0,0,1,0,0,0}
 {0,0,0,0,0,0,0,0,1,0}
 {0,0,1,0,0,0,0,0,0,0}
 {0,1,0,0,0,0,0,0,0,0}
 {0,0,0,0,1,0,0,0,0,0}
 {0,0,0,1,0,0,0,0,0,0}
 {0,0,0,0,0,1,0,0,0,0}
 {0,0,0,0,0,0,0,1,0,0}
 

矩阵的核范数Nuclear norm
SELECT madlib.matrix_nuclear_norm('"mat_A"', 'row=row_id, val=row_vec');
 matrix_nuclear_norm 
---------------------
    118.852685994865

矩阵的秩rank
SELECT madlib.matrix_rank('"mat_A"', 'row=row_id, val=row_vec');
 matrix_rank 
-------------
          10
         
以下是一些稀疏矩阵的操作
密集矩阵转换到稀疏矩阵
SELECT madlib.matrix_sparsify('"mat_B"', 'row=row_id, val=vector',
                               '"mat_B_sparse"', 'col=col_id, val=val');
   matrix_sparsify    
----------------------
 ("""mat_B_sparse""")
(1 row)

SELECT * FROM "mat_B_sparse" ORDER BY row_id, col_id;
 row_id | col_id | val 
--------+--------+-----
      1 |      1 |   9
      1 |      2 |  10
      1 |      3 |   2
      1 |      4 |   4
      1 |      5 |   6
      1 |      6 |   5
      1 |      7 |   3
      1 |      8 |   7
      1 |      9 |   5
      1 |     10 |   6
      2 |      1 |   5
      2 |      2 |   3
      (未显示完)
      
创建稀疏矩阵
CREATE TABLE "mat_A_sparse" (
    "rowNum" integer,
    col_num integer,
    entry integer
);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (1, 1, 9);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (1, 2, 6);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (1, 7, 3);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (1, 8, 10);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (1, 9, 8);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (2, 1, 8);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (2, 2, 2);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (2, 3, 6);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (3, 5, 6);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (3, 6, 3);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (7, 1, 7);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (8, 2, 8);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (8, 3, 5);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (9, 1, 6);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (9, 2, 3);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (10, 10, 0);
select * from "mat_A_sparse";
 rowNum | col_num | entry 
--------+---------+-------
      1 |       1 |     9
      1 |       2 |     6
      1 |       7 |     3
      1 |       8 |    10
      1 |       9 |     8
      2 |       1 |     8
      2 |       2 |     2
      2 |       3 |     6
      3 |       5 |     6
      3 |       6 |     3
      7 |       1 |     7
      8 |       2 |     8
      8 |       3 |     5
      9 |       1 |     6
      9 |       2 |     3
     10 |      10 |     0

求稀疏矩阵的row_dims和col_dim
SELECT madlib.matrix_ndims('"mat_A_sparse"', 'row="rowNum", val=entry');
 matrix_ndims 
--------------
 {10,10}
 
稀疏矩阵置换transpose
--注意"rowNum"的双引号为必须 按照 PostgreSQL 规则 “N”是大写的
--Note the double quotes for "rowNum" are required as per PostgreSQL rules since “N” is capitalized
SELECT madlib.matrix_trans('"mat_A_sparse"', 'row="rowNum", val=entry',
                            'matrix_r_sparse');
   matrix_trans    
-------------------
 (matrix_r_sparse)
(1 row)

SELECT "rowNum", col_num, entry FROM matrix_r_sparse ORDER BY col_num;
 rowNum | col_num | entry 
--------+---------+-------
      1 |       1 |     9
      2 |       1 |     6
      7 |       1 |     3
      8 |       1 |    10
      9 |       1 |     8
      1 |       2 |     8
      2 |       2 |     2
      3 |       2 |     6
      5 |       3 |     6
      6 |       3 |     3
      1 |       7 |     7
      2 |       8 |     8
      3 |       8 |     5
      1 |       9 |     6
      2 |       9 |     3
     10 |      10 |     0
     
稀疏矩阵的主对角main diagonal
SELECT madlib.matrix_extract_diag('"mat_A_sparse"', 'row="rowNum", val=entry');
  matrix_extract_diag  
-----------------------
 {9,2,0,0,0,0,0,0,0,0}

两个矩阵相加然后转换为密集矩阵
SELECT madlib.matrix_add('"mat_A_sparse"', 'row="rowNum", val=entry',
                          '"mat_B_sparse"', 'row=row_id, col=col_id, val=val',
                          'matrix_r_sparse', 'col=col_out');
    matrix_add     
-------------------
 (matrix_r_sparse)
(1 row)

 SELECT madlib.matrix_densify('matrix_r_sparse', 'row="rowNum", col=col_out, val=entry',
                              'matrix_r');
 matrix_densify 
----------------
 (matrix_r)
(1 row)

SELECT * FROM matrix_r ORDER BY "rowNum";
 rowNum |           entry           
--------+---------------------------
      1 | {18,16,2,4,6,5,6,17,13,6}
      2 | {13,5,11,2,8,6,9,7,7,6}
      3 | {0,1,2,3,8,10,7,3,10,1}
      4 | {2,9,0,4,3,6,8,6,3,4}
      5 | {3,8,7,7,0,5,3,9,2,10}
      6 | {5,3,1,7,6,3,5,3,6,4}
      7 | {11,8,4,4,2,7,10,0,3,3}
      8 | {4,14,5,1,3,1,6,6,9,8}
      9 | {12,8,1,7,2,7,10,6,0,6}
     10 | {1,4,4,4,8,5,2,8,5,5}
     
两稀疏矩阵相乘
SELECT madlib.matrix_mult('"mat_A_sparse"', 'row="rowNum", col=col_num, val=entry',
                           '"mat_B_sparse"', 'row=row_id, col=col_id, val=val, trans=true',
                           'matrix_r');
 matrix_mult 
-------------
 (matrix_r)
(1 row)

SELECT * FROM matrix_r ORDER BY "rowNum";
 rowNum |                   entry                   
--------+-------------------------------------------
      1 | {260,216,137,180,190,156,138,222,174,159}
      2 | {104,76,14,34,82,52,72,44,64,40}
      3 | {51,66,33,36,15,45,33,21,33,63}
      4 | {0,0,0,0,0,0,0,0,0,0}
      5 | {0,0,0,0,0,0,0,0,0,0}
      6 | {0,0,0,0,0,0,0,0,0,0}
      7 | {63,35,0,14,21,35,28,28,42,7}
      8 | {90,49,18,72,99,29,84,48,45,52}
      9 | {84,39,3,39,42,39,48,42,51,18}
     10 | {0,0,0,0,0,0,0,0,0,0}
     
初始化一个值为1的稀疏矩阵
SELECT madlib.matrix_ones(5, 4, 'mat_r', 'row=row,col=col, val=val');
 matrix_ones 
-------------
 (mat_r)
(1 row)

SELECT * FROM mat_r ORDER BY row, col;
 row | col | val 
-----+-----+-----
   1 |   1 |   1
   1 |   2 |   1
   1 |   3 |   1
   1 |   4 |   1
   2 |   1 |   1
   2 |   2 |   1
   2 |   3 |   1
   2 |   4 |   1
   3 |   1 |   1
   3 |   2 |   1
   3 |   3 |   1
   3 |   4 |   1
   4 |   1 |   1
   4 |   2 |   1
   4 |   3 |   1
   4 |   4 |   1
   5 |   1 |   1
   5 |   2 |   1
   5 |   3 |   1
   5 |   4 |   1
   
初始化值为0的稀疏矩阵
SELECT madlib.matrix_zeros(5, 4, 'mat_r', 'row=row_id, col=col_id, val=entry');
 matrix_zeros 
--------------
 (mat_r)
(1 row)

SELECT * FROM mat_r;
 row_id | col_id | entry 
--------+--------+-------
      5 |      4 |     0
      
计算矩阵的范数，本例中是Euclidean范数
SELECT madlib.matrix_norm('"mat_A_sparse"', 'row="rowNum", col=col_num, val=entry', '2');
   matrix_norm    
------------------
 24.9399278266799